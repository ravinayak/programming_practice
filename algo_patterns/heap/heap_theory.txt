A binary heap data structure is a nearly complete binary tree meaning that it is
complete at all levels except possibly the last level which is filled from left to right

A max binary heap has the property that any node at index "i" in the binary heap
is always greater than or equal to its children
There is no special ordering amongst the sibling nodes
Max heap property is that for every node "i" other than the root
  A[PARENT(i)] >= A[i] (we leave root because root does not have any parent)
Important Conclusions:
  1.  Value of a node in a binary heap is at most the value of its parent
  2.  Largest element in a max binary heap is stored at the root
  3.  Subtree rooted at a node contains values no longer than the value contained at
      the node itself
  4.  There is no special ordering amongst the Sibling Nodes in a binary heap

An array object A[1:n] with an attribute A.heap_size represents a binary heap where
elements A[1], A[2], A[3] .... A[A.heap_size - 1] of Array A represent nodes of the
binary heap, index "i" of element in Array corresponds to "ith" node of binary heap

Elements A[A.heap_size], A[A.heap_size + 1], A[A.heap_size + 2] ... A[n] are elements
in Array which do not represent nodes in binary heap

Because Binary Heap is a nearly complete binary tree, for a set of "n" nodes, its
maximum height is O(logn). This is because every node has 2 children except nodes
at the (bottom most - 1 level)

Central operation to maintain heap property is
    MAX_HEAPIFY(A,i)
      1. A is the array that contains elements which correspond to nodes in the binary heap
      2. It is assumed that the subtree rooted at node "i" is a max heap with the possibility
         that element A[i] may be less than its left or right child. A[i] may violate the
         max-heap property
      3. MAX_HEAPIFY procedure fixes a possible violation of A[i] node and ensures that the
         binary heap rooted at node "i" is a max heap

Operations on Max Heap
  1. Max Heapify: O(log n)
      Takes an array A and index "i" of node in binary heap and ensures that the binary heap
      rooted at index "i" is a max heap
  2. Build Max Heap: O(n)
      Takes an array A with n elements (1..n) and converts this array into a max heap with
      heap size of "n".
        NOTE: !!IMP!! => We can build a max heap from an array of n elements in LINEAR TIME
                         O(n * log n) seems to be the obvious answer is correct but a deeper
                         analysis reveals a tight upper bound of O(n)
  3. Increase/Decrease Key: O(log n)
      Takes an array A, index "i" of node in binary heap and a new key value "k". When we
      update the value of node at index "i" in binary heap, max heap property may be violated.
      Max Heap property violation is fixed in this method
        a.  If we increase the value of index "i" of node in binary heap, it may becomes greater
            than its parent violating the max heap property
        b.  If we decrease the value of index "i" of node in binary heap, it may becomes smaller
            than its children violating the max heap property
  4. Heapsort: O(n * log n)
      Takes an array A, and sorts elements in it in ascending order